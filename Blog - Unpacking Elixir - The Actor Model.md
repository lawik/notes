This series covers a lot of fundamentals about the underlying BEAM VM and Erlang as consequence of covering Elixir fundamentals. A lot has been said about The Actor Model when it comes to Erlang. That's kind of funny. Because the only thing that as a matter of terminology can be called actors in the Erlang world are Bjarne DÃ¤cker, Joe Armstrong, Mike Williams and Robert Virding as featured in [Erlang: The Movie](https://www.youtube.com/watch?v=xrIjfIjssLE). And it is quite charitable to call them actors. I suspect the would agree.

[The Actor Model](https://en.wikipedia.org/wiki/Actor_model) is generally a model for concurrent computation. And Erlang was [not built to implement Actors](https://erlang.org/pipermail/erlang-questions/2014-June/079794.html). I'm sure we could be debate about whether it does or not. I have not read Carl Hewitt and I'm not going to offer an opinion. It does something similar enough in terms of message passing and spawning. It might be the case that Erlang processes has shifted what people expect an Actor to be. So I will reference The Actor Model as something Erlang and Elixir does for the purposes of this post.

Regardless. The terminology of an "actor" does not exist* in Erlang or Elixir. There is spawning processes, sending messages and receiving them. The typical representative of a high-level, full-featured actor in Erlang is the gen_server (there are also gen_event, gen_statem and other abstractions with different features) and in Elixir we have the GenServer module, etc. A generic server. They are almost exclusively started with a link to the spawning process which should ideally be a Supervisor. I cover more of this under [the resilience part of the series](/unpacking-elixir-resilience.html).

*\*  I actually recently found a use of "actor" in the ecosystem. The Ash Framework uses the term actor for the concept of "the acting party". Typically a user, team or organisation taking an action on a resource. It is unrelated and not in Elixir itself. Amusing though.*

A GenServer is a bunch of logic started as the core loop of an Erlang process. It conforms to a number of useful APIs for debuggability, introspection and as mentioned they tend to be started with [a link](https://www.erlang.org/doc/man/erlang#link-1). Meaning the processes will be aware if the other end of the link exits.

There are three main ways of interacting with a started GenServer. Calls are request/response with a timeout. These are synchronous from the calling side but can be handled in an asynchronous fashion by the GenServer (see returning  a `:noreply` on a call [in the docs](https://hexdocs.pm/elixir/1.12/GenServer.html#c:handle_call/3)).        Then we have a cast which is a fire-and-forget message sent to a GenServer. And then there is regular message passing with `send/2` and related fundamentals. A GenServer is an Erlang process and it can receive messages that are not calls and casts. Similarly it can send messages that are not replies to calls.

For people coming from OOP to Elixir there is often an attempt to map a class and object instantiation to GenServer and a start_link. This is generally an anti-pattern. A GenServer sets the runtime shape of your application and is typically relevant for holding a connection, handling incoming webhook events polling or other runtime concerns. If what you want is to group data and logic, what you want for this is usually a module, probably with an Elixir struct and a bunch of functions. Pure immutable operations. Your actors benefit a lot from modules like this to manage their internal operations.

One example of a typical actor usage is also one of the more agressive uses of the paradigm. The Phoenix LiveView. The LiveView holds a Phoenix Channels WebSocket connection in state. It handles events received from the WebSocket, messages from the system and through these handler functions it can update the state of the LiveView. Every change to the state produces diffs that can be passed to UI over the WebSocket. Every Erlang-style actor exposes an API surface to the surrounding system, the LiveView exposes a subset of it over the WebSocket.

All Erlang processes including GenServers have a process ID, succinctly known as a PID. There are numerous ways of registering, aliasing, grouping and finally addressing them. This can be used to implement messaging patterns such as queue/broker and workers or publish/subscribe (pubsub) internally for the application. Messaging can also traverse an Erlang cluster transparently which is incredibly convenient and powerful. During messaging you don't have to be concerned about where your processes are in the cluster. If you have the PID you can reach them.

Concretely, the Erlang `:pg` module handles Process groups and can register named groups across the cluster in an incredibly convenient way. This is the foundation of Phoenix PubSub. Unless you use the Redis adapter in which case you should* probably move on from Heroku to get the best use out of Elixir.

*\* I snark.*

While all* code in Erlang and Elixir runs in processes and most libraries and tools you work with are built on top of gen_server and friends The Actor Model as implemented in Erlang is not as dominant to what you code looks like as Object-Oriented Programming is. It is not like in Python where "everything is an object" kind of dominates the language. Most of Elixir is a dynamic flavor of Functional Programming. You don't spend all your time doing Actor-stuff. Processes and messaging are underpinnings for the code you write and when you need to deal with state or work needs to be distributed across more units of concurrency. Certainly. However I find most of what I do is basic Functional Programming.

*\*  There are several exceptions. It is true enough but not actually absolutely true. Ports and NIFs are ways of doing things outside of regular Erlang processes.

