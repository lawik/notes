This series covers a lot of fundamentals about the underlying BEAM VM and Erlang as consequence of covering Elixir fundamentals. A lot has been said about The Actor Model when it comes to Erlang. That's kind of funny. Because the only thing that could be called actors in the Erlang world are Bjarne DÃ¤cker, Joe Armstrong, Mike Williams and Robert Virding as featured in [Erlang: The Movie](https://www.youtube.com/watch?v=xrIjfIjssLE). And it is quite charitable to call them actors. I suspect the would agree.

[The Actor Model](https://en.wikipedia.org/wiki/Actor_model) is generally a model for concurrent computation. And Erlang was [not built to implement Actors](https://erlang.org/pipermail/erlang-questions/2014-June/079794.html). I'm sure we could be debate about whether it does or not. I have not read Carl Hewitt. It does something very similar enough in terms of message passing and spawning. It might be the case that Erlang processes has shifted what people expect an Actor to be.

Regardless. The terminology of an "actor" does not exist Erlang or Elixir. There is spawning processes, sending messages and receiving them. The typical representative of a high-level, full-featured actor in Erlang is the gen_server (there are also gen_event, gen_statem and other abstractions with different features) and in Elixir we have the GenServer module. A generic server. They are almost exclusively started with a link to the spawning process which should ideally be a Supervisor. I cover more of this under [the resilience part of the series](/unpacking-elixir-resilience.html).

A GenServer is a bunch of logic started as the core loop of an Erlang process. It conforms to a number of useful APIs for debuggability, introspection and as mentioned they tend to be started with [a link](https://www.erlang.org/doc/man/erlang#link-1). Meaning the processes will be aware if the other end of the link exits.

There are three main ways of interacting with a started GenServer. Calls are request/response with a timeout. These are synchronous from the calling side but can be handled in an asynchronous fashion by the GenServer (see returning  a `:noreply` on a call [in the docs](https://hexdocs.pm/elixir/1.12/GenServer.html#c:handle_call/3)). Then we have a cast which is a fire-and-forget message sent to a GenServer. And then there is regular message passing with `send/2` and related fundamentals. A GenServer is an Erlang process and it can receive messages that are not calls and casts. Similarly it can send messages that are not replies to calls.

For people coming from OOP to Elixir there is often an attempt to map a class and object instantiation to GenServer and a start_link. This is generally an anti-pattern. A GenServer sets the runtime shape of your application and is typically relevant for holding a connection, handling incoming webhook events, polling or other runtime concerns. If what you want is to group data and logic, what you want for this is usually a module, probably with an Elixir struct and a bunch of functions. Pure immutable operations. Your actors benefit a lot from modules like this to manage their internal operations.

One example typical actor usage is LiveView. The LiveView holds a Phoenix Channels WebSocket connection, manages events from the WebSocket, messages from the system and produces diffs that can be passed to UI over the WebSocket. Every Erlang-style actor exposes an API surface, the LiveView exposes a subset of it over the WebSocket.

All Erlang processes including GenServers have a process ID, succinctly known as a PID. There are numerous ways of registering, aliasing, grouping and finally addressing them. This can be used to implement messaging patterns such as queue/broker and workers or publish/subscribe (pubsub) internally for the application. Messaging can also traverse an Erlang cluster transparently which is convenient.